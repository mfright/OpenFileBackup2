package jp.ddhost.ofb_core;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.text.SimpleDateFormat;
import java.util.Date;

public class ofb_core{

	content myContent;

	public static void main(String[] args){
		ofb_core myOFB = new ofb_core();
		myOFB.backup();
	}


	/// MAIN method.
	private void backup(){
		// Load contents.xml
		myContent = xmlLoader.loadXml();
		printf("Copy target:"+myContent.source);
		printf("Copy destination:"+myContent.destination);
		printf("Deleted files will be stored in:"+myContent.deleted+"\r\n");

		search1(new File(myContent.source));

		printf("Backup finished.");
	}



	/// 1.Search all files in the source folder and try to copy all files to the destination folder.
	private void search1(File sourceDir){
		File[] includedFiles = sourceDir.listFiles();

		if( includedFiles == null ){
			return;
		}

		for( File file : includedFiles ) {
			if( !file.exists() )
				continue;
			else if( file.isDirectory() ){
		        search1( file );
			}else if( file.isFile() ){
		        compare( file );
		    }

		}
	}



	/// 2.Search all files in the destination folder and find files that are still deleted from the source folder.
	private void search2(File destDir){
		File[] includedFiles = destDir.listFiles();
		if( includedFiles == null ){
			return;
		}

		for( File file : includedFiles ) {
			if( !file.exists() )
				continue;
			else if( file.isDirectory() ){
		        search2( file );
			}else if( file.isFile() ){
		        compare2( file );
		    }

		}
	}

	private void compare2(File destFile){

		try {
			//コピー先ファイル
			String destFilePath = destFile.getCanonicalPath();


			//コピー元ファイル
			String sourceFilePath = myContent.source + "\\"+destFilePath.substring(myContent.destination.length());
			if(myContent.encryption==true){
				sourceFilePath = sourceFilePath.substring(0,sourceFilePath.length()-6);
			}
			File sourceFile = new File(sourceFilePath);


			//削除済みファイルの退避先フォルダ
			String deletedFilePath="";
			File deletedFile=null;

			//削除済みファイルは退避が必要な場合、退避先ファイル名を決定しておく
			if(myContent.deletedsafe == true){
		        SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHmmss");
		        Date date = new Date();
		        String dateTimeOffset = "_"+sdf.format( date ).toString();

				deletedFilePath = myContent.deleted+"\\"+sourceFilePath.substring(myContent.source.length());
				deletedFilePath = deletedFilePath.substring(0,deletedFilePath.length()-4)+dateTimeOffset+deletedFilePath.substring(deletedFilePath.length()-4);

				deletedFile = new File(deletedFilePath);
			}




			//もしコピー元ファイルが無くなっていた場合
			if(!sourceFile.exists()){
				if(myContent.deletedsafe){
					//削除済みファイルとして退避する。
					destFile.renameTo(deletedFile);

				}else{
					//ファイルを消す。
					destFile.delete();
				}
			}


		} catch (IOException e) {
			e.printStackTrace();
		}
	}





	/// コピー元ファイルとコピー先ファイルを比較し、必要に応じてコピーする。
	private void compare(File sourceFile){
		try {
			//コピー元ファイル
			String sourceFilePath = sourceFile.getCanonicalPath();


			//コピー先ファイル
			String destFilePath = myContent.destination+"\\"+sourceFilePath.substring(myContent.source.length());
			if(myContent.encryption==true){
				destFilePath += "__.zip";
			}
			File destFile = new File(destFilePath);


			//削除済みファイルの退避先フォルダ
			String deletedFilePath="";
			File deletedFile=null;

			//削除済みファイルは退避が必要な場合、退避先ファイル名を決定しておく
			if(myContent.deletedsafe == true){
		        SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHmmss");
		        Date date = new Date();
		        String dateTimeOffset = "_"+sdf.format( date ).toString();

				deletedFilePath = myContent.deleted+"\\"+sourceFilePath.substring(myContent.source.length());
				deletedFilePath = deletedFilePath.substring(0,deletedFilePath.length()-4)+dateTimeOffset+deletedFilePath.substring(deletedFilePath.length()-4);

				if(myContent.encryption==true){
					deletedFilePath += "__.zip";
				}
				deletedFile = new File(deletedFilePath);
			}


			//バックアップ対象から除外されているとき
			if(myContent.isExcluded(sourceFilePath)){
				//バックアップしない
				printf("Excluded:"+sourceFilePath);
				return;
			}


			// バックアップ先にすでにファイルがある場合
			if(destFile.exists()){

				// 双方の最終更新日時を取得
				Long sourceLastModified = sourceFile.lastModified();
				Long destLastModified = destFile.lastModified();

				// ファイルの最終更新日時が一緒の場合
				if(sourceLastModified.equals(destLastModified)){
					printf("No_change:"+sourceFilePath);
					//処理を抜ける。
					return;

				// ファイルの更新日時は違うのでコピーしたいが、バックアップ先にすでにファイルがある場合、すでにあるバックアップを退避先へコピーする。
				}else if(myContent.deletedsafe == true){
					printf("COPY:"+destFilePath + " > "+deletedFilePath);
					Files.copy(destFile.toPath(), deletedFile.toPath(),StandardCopyOption.REPLACE_EXISTING);
				}

			}


			//ファイルをコピーする。
			printf("COPY:"+sourceFilePath + " > "+destFilePath);
			if(myContent.encryption== true){
				//zip暗号化が有効なとき
				//zip圧縮する。
				fileArchiever.archieve(sourceFilePath, destFilePath, myContent.encryptPassword);

				//最終更新日時を一致させる。
				Long lastModified = sourceFile.lastModified();
				destFile.setLastModified(lastModified);

			}else{
				//zip暗号化が無効なとき
				Files.copy(sourceFile.toPath(),destFile.toPath(),StandardCopyOption.REPLACE_EXISTING);
			}


		} catch (IOException e) {
			e.printStackTrace();
		}
	}






	/// 標準出力
	private void printf(String message){
		System.out.println(message);
	}
}